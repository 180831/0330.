public class Solution {
    /**
     * 计算你能获得的最大收益
     * 
     * @param prices Prices[i]即第i天的股价
     * @return 整型
     */
    public int calculateMax(int[] prices) {
        //获取买卖的天数
        int n = prices.length;
        //可进行买卖的次数
        int max_k = 2;
        //三维数组表示  有几天/可以出手的次数/现在持有股票还是没有持有股票
        int[][][] dp = new int[n][max_k + 1][2];
        //第一天
        //当手中没有持有股票时，值都为0
        //当手中持有股票时，都是直接进行购买当天的股票(从第一天开始才能购买股票)
         for (int i = 0; i < n; i++) {
            for (int j = 0; j < 3; j++) {
                dp[i][j][0] = 0;
                dp[i][j][1] = -prices[i];
            }
        }
        //开始，从第二天开始算买还是不买股票
        for (int i = 1; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
//解释：当今天不持有股票的情况有2种：情况1：昨天本来就没有持有股票，今天继续不购买，情况2 昨天持有股票，今天把股票出售了，所以利润为昨天的持有股票利润值加出售股票
                
                 dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
//解释：当今天持有股票时的情况有两种：情况1：昨天本来就持有股票，所以今天不买卖，继续保持昨天的利润状态，情况2：昨天没有持有股票，今天购买，所以利润值为昨天没有持有股票的情况下减去购买股票的钱，注意购买了股票需要再次数k减去1
                 dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }
    // 穷举了 n × max_k × 2 个状态，正确。返回最终经过n天，交易max_k次之后，手中没有股票的值
        return dp[n - 1][max_k][0];
    }
}